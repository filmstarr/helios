<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<title>helios</title>
<script type="text/javascript" src="scripts\jquery-2.1.1.min.js"></script>
<script type="text/javascript" src="scripts\jquery-ui.min.js"></script>
<script type="text/javascript" src="scripts\paper-full.min.js"></script>
<script type="text/javascript" src="scripts\suncalc.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    $("#canvas").fadeIn(1500, "easeInOutQuart");
  });

</script>
<script type="text/paperscript" canvas="canvas">

  //Define parameters
  var sunRadius = 10;
  var xBuffer = 0;
  var yBuffer = 240 + 1 + sunRadius;
  var xSize = ((window.innerWidth > 0) ? window.innerWidth : screen.width) - (2 * xBuffer);
  var ySize = 200;
  var lineColour = 'white';


  //Initialise objects
  var location = new Location();
  var sunTimes = new SunTimes(location);
  var altimeter = new Altimeter(sunTimes);
  var heliosPath = new HeliosPath(altimeter, sunTimes.DegreeMidday, lineColour, xSize, yBuffer);
  var horizon = new Horizon(altimeter, sunTimes.Sunrise, lineColour, xSize, yBuffer);
  var helios = new Helios(altimeter, horizon.HorizonYCoordinate, lineColour, sunRadius, xSize, yBuffer);


  //Events
  function onFrame(event) {
    location.Update(locationCallback);
    sunTimes.Update(location);
    heliosPath.Update(sunTimes.DegreeMidday);
    horizon.Update(sunTimes.Sunrise);
    helios.Update(horizon.HorizonYCoordinate);
  }

  function locationCallback() {
    sunTimes.Update(location);
    heliosPath.Update(sunTimes.DegreeMidday);
    horizon.Update(sunTimes.Sunrise);
  }


  //Objects
  function Location() {
    var latitude = localStorage.latitude ? localStorage.latitude : 0;
    var longitude = localStorage.longitude ? localStorage.longitude : 0;
    this.__defineGetter__("Latitude", function(){ return latitude; });
    this.__defineGetter__("Longitude", function(){ return longitude; });

    var secondsInDay = 60 * 60 * 24;
    var previousRequest = new Date(1970, 1, 1, 0, 0, 0, 0);

    this.Update = function(callback) {
      var date = new Date();
      //Update location once a day or if we have no data try each hour
      var requiresUpdate = (!localStorage.locationAsOf || date - localStorage.locationAsOf >= 1000 * secondsInDay) && date - previousRequest >= 1000 * 60 * 60;
      previousRequest = date;

      if (requiresUpdate){
        console.log('Requesting location...');
        $.ajax({
          url: 'http://freegeoip.net/json/', 
          type: 'POST', 
          dataType: 'jsonp',
          success: function(location) {
            latitude = location.latitude;
            longitude = location.longitude;
            localStorage.latitude = latitude;
            localStorage.longitude = longitude;
            localStorage.locationAsOf = new Date();
            callback();
            console.log('Location retrieved (latitude: ' + latitude + ', longitude: ' + longitude + ').');
          }
        });
      }
    }
  }

  function SunTimes(location) {
    var sunrise = new Date(1970, 1, 1, 0, 0, 0, 0);
    var sunset = new Date(1970, 1, 1, 0, 0, 0, 0);
    var degreeMidday = new Date(1970, 1, 1, 0, 0, 0, 0);
    this.__defineGetter__("Sunrise", function(){ return sunrise; });
    this.__defineGetter__("Sunset", function(){ return sunset; });
    this.__defineGetter__("DegreeMidday", function(){ return degreeMidday; });
    this.Update = update;

    var secondsInDay = 60 * 60 * 24;
    var previousRequest = new Date(1970, 1, 1, 0, 0, 0, 0);
    var latitude = location.Latitude;
    var longitude = location.Longitude;
    update(location);

    function update(location) {
      var date = (new Date()).setHours(0,0,0,0);
      if (date > previousRequest || latitude != location.Latitude || longitude != location.Longitude) {
        var times = SunCalc.getTimes(new Date(), location.Latitude, location.Longitude);
        sunrise = times.sunrise;
        sunset = times.sunset;
        var midday = (secondsSinceStartOfDay(sunrise) + secondsSinceStartOfDay(sunset)) / 2;
        degreeMidday = 360 * midday / secondsInDay;
        latitude = location.Latitude;
        longitude = location.Longitude;
        previousRequest = date;
      }
    }

    function secondsSinceStartOfDay(date) {
      return date.getSeconds() + (60 * date.getMinutes()) + (60 * 60 * date.getHours());
    }
  }

  function Altimeter(sunTimes) {
    this.FractionalTime = fractionalTime;
    this.Altitude = altitude;

    function fractionalTime(date) {
      var secondsInDay = 60 * 60 * 24;
      var seconds = secondsSinceStartOfDay(date);
      return seconds / secondsInDay;
    }

    function secondsSinceStartOfDay(date) {
      return date.getSeconds() + (60 * date.getMinutes()) + (60 * 60 * date.getHours());
    }

    function altitude(fractionalTime) {
      var degreeTime = 360 * fractionalTime;
      var fractionalAltitude = (1 + Math.cos((degreeTime + 180 - sunTimes.DegreeMidday) * Math.PI / 180)) / 2;
      return fractionalAltitude * ySize;
    }
  }

  function HeliosPath(altimeter, degreeMidday, colour, xSize, yBuffer) {
    this.Update = update;
    var pathPoints = 360;
    var heliosPath = new Path();
    heliosPath.strokeColor = colour;
    var previousRequest = new Date(1970, 1, 1, 0, 0, 0, 0);
    update(degreeMidday);

    function update(newDegreeMidday) {
      var date = (new Date()).setHours(0,0,0,0);
      if (date > previousRequest || degreeMidday != newDegreeMidday) {
        heliosPath.removeSegments();
        for (var i = 0; i <= pathPoints; i++) {
          var point = new Point(xBuffer + ( xSize * i / pathPoints), yBuffer + altimeter.Altitude(i / pathPoints));
          heliosPath.add(point);
        }
        heliosPath.smooth();
        heliosPath.simplify();
        degreeMidday = newDegreeMidday;
        previousRequest = date;
      }
    }
  }

  function Horizon(altimeter, sunrise, colour, xSize, yBuffer) {
    var horizonYCoordinate = 0;
    this.__defineGetter__("HorizonYCoordinate", function(){ return horizonYCoordinate; });
    this.Update = update;

    var horizon = new Path.Line();
    horizon.strokeColor = colour;
    var previousRequest = new Date(1970, 1, 1, 0, 0, 0, 0);
    update(sunrise);

    function update(newSunrise) {
      var date = (new Date()).setHours(0,0,0,0);
      if (date > previousRequest || sunrise != newSunrise) {
        horizon.removeSegments();
        var horizonAltitude = altimeter.Altitude(altimeter.FractionalTime(newSunrise));
        horizonYCoordinate = yBuffer + horizonAltitude;
        var from = new Point(xBuffer, horizonYCoordinate);
        var to = new Point(xBuffer + xSize, horizonYCoordinate);
        horizon.add(from);
        horizon.add(to);
        sunrise = newSunrise;
        previousRequest = date;
      }
    }
  }

  function Helios(altimeter, horizon, colour, radius, xSize, yBuffer) {
    this.Update = update;
    var glow = 100;
    var framesPerSecond = 1;
    var horizonYCoordinate = 0;
    var previousRequest = new Date(1970, 1, 1, 0, 0, 0, 0);
    var modifiedAnimationDuration = 0;

    //Our main helios circle
    var heliosCircle = new Path.Circle(-(glow + 1), 0, glow);
    heliosCircle.fillColor = {
        gradient: {
            stops: [['white', radius/glow], ['yellow', radius/glow], [new RgbColor(1, 1, 1, 0.2), 0.5], [new RgbColor(1, 1, 1, 0.0), 1]],
            radial: true
        },
        origin: heliosCircle.position,
        destination: heliosCircle.bounds.rightCenter
    };

    //The outline for use when helios is below the horizon
    var heliosOutline = new Path.Circle(-(radius + 1), 0, radius);
    heliosOutline.strokeColor = 'white';

    //Objects for use when helios is exiting the screen
    var wrapCircle = heliosCircle.clone();
    var wrapOutline = heliosOutline.clone();

    update(horizon);

    function update(newHorizon) {
      var date = new Date();
      if (date - previousRequest >= 1000 / framesPerSecond) {
        var timeFraction = altimeter.FractionalTime(date);
        //Run the animation faster
        if (modifiedAnimationDuration != 0) {
          timeFraction = (date.getMilliseconds() + ((date.getSeconds() % modifiedAnimationDuration) * 1000)) / (1000 * modifiedAnimationDuration);
        }
        heliosCircle.position.x = heliosOutline.position.x = xBuffer + (xSize * timeFraction);
        heliosCircle.position.y = heliosOutline.position.y = yBuffer + altimeter.Altitude(timeFraction);

        if (newHorizon != horizonYCoordinate || !horizonYCoordinate) {
          horizonYCoordinate = newHorizon;
          clip(horizonYCoordinate);
        }
        sunset();
        wrapHelios();
        previousRequest = date;
      }
    }

    function clip(horizonYCoordinate) {
      var from = new Point(0, 0);
      var to = new Point(xSize, horizonYCoordinate);
      var aboveHorizon = new Path.Rectangle(from, to);
      var group = new Group(aboveHorizon,heliosCircle,wrapCircle);
      group.clipped = true;
    }

    function sunset() {
      //How close to the horizon do we want the sunset to kick in
      var sunsetProximity = 2 * radius;

      //The green level is determined by how far we are through the sunset
      var green = 1- ((heliosCircle.position.y + sunsetProximity - horizonYCoordinate) / sunsetProximity);
      
      //Clip to 0.4 -> 1
      green = Math.max(Math.min(green,1),0);
      green = 0.6 * (((1/0.6)-1) + green);

      //Add twilight once the sun is below the horizon
      var twilight = (heliosCircle.position.y - horizonYCoordinate) / (3 * radius);
      twilight = Math.max(Math.min(twilight,1),0);

      //Set
      heliosCircle.fillColor.gradient.stops[1].color = new Color(1 - twilight, Math.max(green - twilight, 0), 0.2 * twilight);
    }

    //Use second object to create wrapping effect
    function wrapHelios() {
      if (heliosCircle.position.x + glow > xBuffer + xSize) {
        wrapCircle.position.x = wrapOutline.position.x = heliosCircle.position.x - (xBuffer + xSize);
        wrapCircle.position.y = wrapOutline.position.y = heliosCircle.position.y;
        wrapCircle.fillColor.gradient.stops[1].color = heliosCircle.fillColor.gradient.stops[1].color;
      } else if (heliosCircle.position.x < glow) {
        wrapCircle.position.x = wrapOutline.position.x = heliosCircle.position.x + (xBuffer + xSize);
        wrapCircle.position.y = wrapOutline.position.y = heliosCircle.position.y;
        wrapCircle.fillColor.gradient.stops[1].color = heliosCircle.fillColor.gradient.stops[1].color;
      } else {
        wrapCircle.position.x = wrapOutline.position.x = -(glow + 1);
      }
    }

    heliosCircle.onClick = function(event) {
      modifiedAnimationDuration = modifiedAnimationDuration == 30 ? 50 : modifiedAnimationDuration;
      modifiedAnimationDuration = (modifiedAnimationDuration + 10) % 70;
      framesPerSecond = modifiedAnimationDuration == 0 ? 1 : 60;
    }
  }

</script>
</head>

<body style="margin: 0;">
	<canvas id="canvas" resize style="display: none;"></canvas>
</body>

</html>