<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<title>helios</title>
<script type="text/javascript" src="scripts\jquery-2.1.1.min.js"></script>
<script type="text/javascript" src="scripts\jquery-ui.min.js"></script>
<script type="text/javascript" src="scripts\paper-full.min.js"></script>
<script type="text/javascript" src="scripts\suncalc.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    $("#canvas").fadeIn(1500, "easeInOutQuart");
  });

</script>
<script type="text/paperscript" canvas="canvas">

  //Define parameters
  var sunRadius = 10;
  var xBuffer = 0;
  var yBuffer = 240 + 1 + sunRadius;
  var xSize = ((window.innerWidth > 0) ? window.innerWidth : screen.width) - (2 * xBuffer);
  var ySize = 200;
  var lineColour = 'white';

  //Create objects
  var location = new Location();
  var sunTimes = new SunTimes(location);
  var altimeter = new Altimeter(sunTimes);
  var heliosPath = new HeliosPath(altimeter, lineColour, xSize, yBuffer);
  var horizon = new Horizon(altimeter, lineColour, xSize, yBuffer);
  var helios = new Helios(altimeter, lineColour, sunRadius, xSize, yBuffer);






  //Events
  var previousSunriseSunsetRequestDate = new Date(1970, 1, 1, 0, 0, 0, 0);
  function onFrame(event) {

    location.UpdateIfRequired(UpdateObjects);

    //Update sunrise and sunset when the date changes
    var date = (new Date()).setHours(0,0,0,0);
    if (date > previousSunriseSunsetRequestDate) {
      sunTimes = new SunTimes(location);
      heliosPath.Sight();
      horizon.Sight(sunTimes.Sunrise);
      previousSunriseSunsetRequestDate = date;
    }

    helios.Sight(horizon.HorizonYCoordinate);
  }

  function UpdateObjects() {
    sunTimes = new SunTimes(location);
    heliosPath.Sight();
    horizon.Sight(sunTimes.Sunrise);
  }










  //Objects
  function Location() {
    var secondsInDay = 60 * 60 * 24;
    var previousRequest = new Date(1970, 1, 1, 0, 0, 0, 0);
    this.Latitude = localStorage.latitude ? localStorage.latitude : 0;
    this.Longitude = localStorage.longitude ? localStorage.longitude : 0;

    this.UpdateIfRequired = function(callback) {
      var date = new Date();
      //Update location once a day or if we have no data try each hour
      var requiresUpdate = (!localStorage.locationAsOf || date - localStorage.locationAsOf >= 1000 * secondsInDay) && date - previousRequest >= 1000 * 60 * 60;
      previousRequest = date;

      if (requiresUpdate){
        console.log('Requesting location...');
        $.ajax({
          url: 'http://freegeoip.net/json/', 
          type: 'POST', 
          dataType: 'jsonp',
          success: function(location) {
            this.Latitude = location.latitude;
            this.Longitude = location.longitude;
            localStorage.latitude = this.Latitude;
            localStorage.longitude = this.Longitude;
            localStorage.locationAsOf = new Date();
            callback();
            console.log('Location retrieved (latitude: ' + this.Latitude + ', longitude: ' + this.Longitude + ').');
          }
        });
      }
    }
  }

  function SunTimes(location) {
    var secondsInDay = 60 * 60 * 24;
    var times = SunCalc.getTimes(new Date(), location.Latitude, location.Longitude);
    this.Sunrise = times.sunrise;
    this.Sunset = times.sunset;
    var midday = (secondsSinceStartOfDay(this.Sunrise) + secondsSinceStartOfDay(this.Sunset)) / 2;
    this.DegreeMidday = 360 * midday / secondsInDay;

    function secondsSinceStartOfDay(date) {
      return date.getSeconds() + (60 * date.getMinutes()) + (60 * 60 * date.getHours());
    }
  }

  function Altimeter(sunTimes) {
    this.FractionalTime = fractionalTime;
    this.Altitude = altitude;

    function fractionalTime(date) {
      var secondsInDay = 60 * 60 * 24;
      var seconds = secondsSinceStartOfDay(date);
      return seconds / secondsInDay;
    }

    function secondsSinceStartOfDay(date) {
      return date.getSeconds() + (60 * date.getMinutes()) + (60 * 60 * date.getHours());
    }

    function altitude(fractionalTime) {
      var degreeTime = 360 * fractionalTime;
      var fractionalAltitude = (1 + Math.cos((degreeTime + 180 - sunTimes.DegreeMidday) * Math.PI / 180)) / 2;
      return fractionalAltitude * ySize;
    }
  }

  function HeliosPath(altimeter, colour, xSize, yBuffer) {
    var pathPoints = 360;
    var heliosPath = new Path();
    heliosPath.strokeColor = colour;

    //Update items
    function sight() {
      heliosPath.removeSegments();
      for (var i = 0; i <= pathPoints; i++) {
        var point = new Point(xBuffer + ( xSize * i / pathPoints), yBuffer + altimeter.Altitude(i / pathPoints));
        heliosPath.add(point);
      }
      heliosPath.smooth();
      heliosPath.simplify();
    }
    this.Sight = sight;
  }

  function Horizon(altimeter, colour, xSize, yBuffer) {
    this.HorizonYCoordinate = 0;

    var horizon = new Path.Line();
    horizon.strokeColor = colour;

    function sight(sunrise) {
      horizon.removeSegments();
      var horizonAltitude = altimeter.Altitude(altimeter.FractionalTime(sunrise));
      this.HorizonYCoordinate = yBuffer + horizonAltitude;

      var from = new Point(xBuffer, this.HorizonYCoordinate);
      var to = new Point(xBuffer + xSize, this.HorizonYCoordinate);

      horizon.add(from);
      horizon.add(to);
    }
    this.Sight = sight;
  }

  function Helios(altimeter, colour, radius, xSize, yBuffer) {
    var glow = 100;
    var framesPerSecond = 1;
    var horizonYCoordinate = 0;
    var previousRequest = new Date(1970, 1, 1, 0, 0, 0, 0);

    var heliosCircle = new Path.Circle(-(glow + 1), 0, glow);
    heliosCircle.fillColor = {
        gradient: {
            stops: [['white', radius/glow], ['yellow', radius / glow], [new RgbColor(1, 1, 1, 0.2), 0.5], [new RgbColor(1, 1, 1, 0.0), 1]],
            radial: true
        },
        origin: heliosCircle.position,
        destination: heliosCircle.bounds.rightCenter
    };
    var heliosOutline = new Path.Circle(-(radius + 1), 0, radius);
    heliosOutline.strokeColor = 'white';

    function sight(newHorizon) {
      var date = new Date();
      if (date - previousRequest >= 1000 / framesPerSecond) {
        var timeFraction = altimeter.FractionalTime(date);
        //Run the animation faster
        if (framesPerSecond != 1) {
          timeFraction = (date.getMilliseconds() + ((date.getSeconds() % 10) * 1000)) / (1000 * 10);
        }
        heliosCircle.position.x = heliosOutline.position.x = xBuffer + (xSize * timeFraction);
        heliosCircle.position.y = heliosOutline.position.y = yBuffer + altimeter.Altitude(timeFraction);

        if (newHorizon != horizonYCoordinate || !horizonYCoordinate) {
          horizonYCoordinate = newHorizon;
          clip(horizonYCoordinate);
        }
        previousRequest = date;
      }
    }
    this.Sight = sight;

    function clip(horizonYCoordinate) {
      var from = new Point(0, 0);
      var to = new Point(xSize, horizonYCoordinate);
      var aboveHorizon = new Path.Rectangle(from, to);
      var group = new Group(aboveHorizon,heliosCircle);
      group.clipped = true;
    }

    heliosCircle.onClick = function(event) {
      framesPerSecond = framesPerSecond == 1 ? 600 : 1;
    }
  }

</script>
</head>

<body style="margin: 0;">
	<canvas id="canvas" resize style="display: none; background-color: lightsteelblue;"></canvas>
</body>

</html>